<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>视频捕捉和绘制</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
    <div>
        <h2>摄像头和绘制预览</h2>
        <div style="position: relative; width: 1280px; height: 720px;">
            <video id="combinedPreview" width="1280px" height="720px" autoplay></video>
            <canvas id="drawingCanvas" style="position: absolute; top: 0; left: 0;" width="480" height="360"></canvas>
        </div>
    </div>

    <script>
        const combinedPreview = document.getElementById("combinedPreview");
        const drawingCanvas = document.getElementById("drawingCanvas");
        const drawingContext = drawingCanvas.getContext("2d");

        function startCombinedPreview() {
            const constraints = { video: true, audio: false };
            navigator.mediaDevices.getUserMedia(constraints)
                .then(async stream => {
                    combinedPreview.srcObject = stream;
                    const cameraStream = combinedPreview.captureStream();

                    // const fps = 25;
                    // setInterval(() => {
                    //     drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    //     drawingContext.fillStyle = "red";
                    //     drawingContext.fillRect(50, 50, 100, 100); // 示例：在canvas上绘制一个红色矩形
                    // }, 1000 / fps);

                    // const combinedStream = new MediaStream([...cameraStream.getVideoTracks(), ...drawingCanvas.captureStream(fps).getVideoTracks()]);
                    // combinedPreview.srcObject = combinedStream;
                    // 把视频图片传给hands
                    await hands.send({ image: combinedPreview });
                })
                .catch(error => {
                    console.error('getUserMedia error:', error);
                });
        }

        startCombinedPreview();


        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        function onResults(results) {
            drawingContext.save();
            drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingContext.drawImage(
                results.image, 0, 0, drawingCanvas.width, drawingCanvas.height);
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let index = 0; index < results.multiHandLandmarks.length; index++) {
                    const classification = results.multiHandedness[index];
                    const isRightHand = classification.label === 'Right';
                    const landmarks = results.multiHandLandmarks[index];
                    // drawConnectors(
                    //     canvasCtx, landmarks, HAND_CONNECTIONS,
                    //     // 右手骨架、左手骨架
                    //     { color: isRightHand ? '#00FF00' : '#FF0000' });
                    // drawLandmarks(canvasCtx, landmarks, {
                    //     // 右手关键点轮廓、左手关键点轮廓
                    //     color: isRightHand ? '#069BDF' : '#79DA5E',
                    //     // 右手关键点填充、左手关键点填充
                    //     fillColor: isRightHand ? '#E03397' : '#0AA94D',
                    //     radius: (x) => {
                    //         return lerp(x.from.z, -0.15, .1, 10, 1);
                    //     }
                    // });
                    // 获取标记点13和14
                    const landmark13 = landmarks[13];
                    const landmark14 = landmarks[14];
                    // 计算中点
                    const midpoint = {
                        x: (landmark13.x + landmark14.x) / 2,
                        y: (landmark13.y + landmark14.y) / 2
                    };
                    landmark14.x = midpoint.x;
                    landmark14.y = midpoint.y;
                    drawLandmarks(drawingContext, [landmark14], {
                        // 右手关键点轮廓黄色、左手关键点轮廓紫色
                        color: isRightHand ? '#FFFF00' : '#9400D3',
                        // 右手关键点填充、左手关键点填充
                        fillColor: isRightHand ? '#FFFF00' : '#9400D3',
                        radius: (x) => {
                            return lerp(x.from.z, -0.15, .1, 10, 1);
                        }
                    });
                }
            }
            drawingContext.restore();
        }

    </script>
</body>

</html>